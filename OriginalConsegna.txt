Certamente. Ecco la consegna del progetto, formulata in modo chiaro e diretto, prima in italiano e poi in inglese.

Italiano

Titolo del Progetto: Controllore per Camera di Fermentazione di Precisione con Architettura a Oggetti e Logica Predittiva

Obiettivo Generale:
L'obiettivo è sviluppare un firmware completo per un sistema embedded basato su Arduino, capace di gestire con precisione una camera di fermentazione. Il progetto deve dimostrare competenze avanzate di programmazione attraverso l'implementazione di un'architettura software a Classi (Object-Oriented Programming), la gestione di problematiche hardware reali come il debouncing dei pulsanti, l'utilizzo di interrupt per eventi critici e l'implementazione di una logica di controllo predittiva per ottimizzare le prestazioni del sistema.

Architettura Hardware (da realizzare su Tinkercad):
Il circuito deve essere composto dai seguenti elementi, collegati a un Arduino Uno R3:

Sensore di Temperatura (TMP36): Per misurare con precisione la temperatura interna della camera.

Sensore di Gas (MQ-3): Per simulare il monitoraggio di un sottoprodotto della fermentazione, come l'etanolo.

Display LCD 16x2 con modulo I2C: Per visualizzare in tempo reale lo stato del sistema, i dati dei sensori e le impostazioni.

Potenziometro: Per permettere all'utente di impostare dinamicamente la temperatura desiderata (setpoint).

Pulsante di Navigazione: Per ciclare tra le diverse schermate informative visualizzate sul display.

Transistor: Collegato a un elemento riscaldante (simulato da un motore DC o una resistenza di potenza) per controllare attivamente la temperatura.

LED Bicolore (o un LED Rosso e uno Verde): Per fornire un'indicazione visiva immediata dello stato operativo del sistema.

Pulsante di Arresto d'Emergenza: Un pulsante dedicato per la gestione di eventi critici.

Architettura Software e Requisiti Funzionali:

Struttura a Classi (OOP): Il firmware deve essere obbligatoriamente progettato seguendo un'architettura a Classi, separando le responsabilità in file .h e .cpp distinti. Dovranno essere create almeno le seguenti classi: SensorManager (per la gestione di tutte le letture dei sensori), ActuatorController (per il controllo del transistor e del LED), DisplayManager (per ogni interazione con l'LCD), DebouncedButton (una classe riutilizzabile per la gestione del pulsante di navigazione) e SystemState (che contiene la logica principale e la macchina a stati).

Gestione degli Input con Debouncing: Il pulsante di navigazione deve essere gestito tramite una logica di debouncing software per prevenire letture multiple e indesiderate, garantendo che ogni pressione venga registrata una sola volta in modo affidabile. La classe DebouncedButton deve implementare questa logica utilizzando la funzione millis().

Gestione degli Interrupt: Il pulsante di Arresto d'Emergenza deve essere collegato a un pin di interrupt esterno dell'Arduino (pin 2 o 3). La sua pressione deve attivare una Interrupt Service Routine (ISR) che arresta immediatamente ogni operazione critica (in particolare, disattivando l'elemento riscaldante) e porta il sistema in uno stato di sicurezza, indipendentemente dall'operazione in corso.

Logica di Controllo e Macchina a Stati Finiti (FSM): Il sistema deve operare secondo una macchina a stati ben definita, che includa almeno gli stati: STANDBY (in attesa di comandi), PREHEATING (riscaldamento iniziale per raggiungere il setpoint), MAINTAINING (mantenimento della temperatura) e EMERGENCY_STOP (attivato dall'interrupt).

Logica di Controllo Predittiva: Durante lo stato MAINTAINING, il sistema non deve limitarsi a riattivare il riscaldamento solo quando la temperatura scende sotto una soglia minima. Invece, deve analizzare la velocità con cui la temperatura sta diminuendo (la sua derivata nel tempo) per poter attivare il riscaldatore in modo proattivo, con brevi impulsi, anticipando la discesa sotto la soglia e garantendo così una maggiore stabilità termica e un minor consumo energetico.

Interfaccia Utente su LCD: Il display LCD deve fornire un feedback visivo chiaro, mostrando lo stato corrente, la temperatura attuale, il setpoint impostato tramite potenziometro e messaggi di allarme o di stato (es. "Riscaldamento...", "Temperatura Stabile", "ARRESTO DI EMERGENZA").

Piattaforma di Sviluppo e Test:
L'intero progetto, inclusi il circuito elettronico e il firmware, deve essere sviluppato, assemblato e testato interamente all'interno della piattaforma di simulazione Autodesk Tinkercad.

English

Project Title: Precision Fermentation Chamber Controller with Object-Oriented Architecture and Predictive Logic

General Objective:
The objective is to develop a complete firmware for an Arduino-based embedded system, capable of precisely managing a fermentation chamber. The project must demonstrate advanced software engineering skills through the implementation of an Object-Oriented Programming (OOP) architecture, the management of real-world hardware issues like button debouncing, the use of interrupts for critical events, and the implementation of predictive control logic to optimize system performance.

Hardware Architecture (to be built in Tinkercad):
The circuit must be composed of the following components, connected to an Arduino Uno R3:

Temperature Sensor (TMP36): To accurately measure the internal temperature of the chamber.

Gas Sensor (MQ-3): To simulate the monitoring of a fermentation by-product, such as ethanol.

16x2 LCD Display with I2C module: To provide a real-time display of the system status, sensor data, and settings.

Potentiometer: To allow the user to dynamically set the desired temperature (setpoint).

Navigation Button: To cycle through the different information screens displayed on the LCD.

1-Channel Relay: Connected to a heating element (simulated by a DC motor or a power resistor) to actively control the temperature.

Bi-color LED (or one Red and one Green LED): To provide an immediate visual indication of the system's operational status.

There are 2 level of emergency.
Low level emergency: the red light is activated.
High level emergency: the siren is activated.
(to decide when is low and when is high)

in case of emergency a siren is also activated.

Emergency Stop Button: A dedicated button for handling critical events.

Software Architecture and Functional Requirements:

Object-Oriented (OOP) Structure: The firmware must be designed following a mandatory Object-Oriented architecture, separating responsibilities into distinct .h and .cpp files. At a minimum, the following classes must be created: SensorManager (for handling all sensor readings), ActuatorController (for controlling the transistor and LED), DisplayManager (for all interactions with the LCD), DebouncedButton (a reusable class for managing the navigation button), and SystemState (which contains the main logic and the state machine).


Input Management with Debouncing: The navigation button must be managed using software debouncing logic to prevent multiple, unwanted readings, ensuring that each press is reliably registered only once. The DebouncedButton class must implement this logic using the millis() function.

Interrupt Handling: The Emergency Stop button must be connected to an external interrupt pin on the Arduino (pin 2 or 3). Pressing it must trigger an Interrupt Service Routine (ISR) that immediately stops all critical operations (specifically, deactivating the heating element) and puts the system into a safe state, regardless of the ongoing operation.

Control Logic and Finite State Machine (FSM): The system must operate according to a well-defined state machine, which includes at least the following states: STANDBY (waiting for commands), PREHEATING (initial heating to reach the setpoint), MAINTAINING (maintaining the temperature), and EMERGENCY_STOP (activated by the interrupt).

Predictive Control Logic: During the MAINTAINING state, the system must not simply reactivate the heater only when the temperature drops below a minimum threshold. Instead, it must analyze the rate at which the temperature is decreasing (its derivative over time) to proactively activate the heater with short pulses, anticipating the drop below the threshold, thus ensuring greater thermal stability and lower energy consumption.

User Interface on LCD: The LCD display must provide clear visual feedback, showing the current state, the current temperature, the setpoint adjusted via the potentiometer, and status or alarm messages (e.g., "Heating...", "Temperature Stable", "EMERGENCY STOP").

Development and Testing Platform:
The entire project, including the electronic circuit and the firmware, must be developed, assembled, and tested entirely within the Autodesk Tinkercad simulation platform.